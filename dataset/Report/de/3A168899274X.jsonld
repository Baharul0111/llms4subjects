{
    "@graph": [
        {
            "@id": "gnd:1068096934",
            "sameAs": "Universitätsverlag Potsdam"
        },
        {
            "@id": "gnd:1069348694",
            "sameAs": "Schneider, Sven"
        },
        {
            "@id": "gnd:131769251",
            "sameAs": "Lambers, Leen"
        },
        {
            "@id": "gnd:4006650-2",
            "sameAs": "Bildung"
        },
        {
            "@id": "gnd:4053474-1",
            "sameAs": "Schule"
        },
        {
            "@id": "gnd:4123065-6",
            "sameAs": "Digitalisierung"
        },
        {
            "@id": "gnd:7623494-0",
            "sameAs": "Cloud Computing"
        },
        {
            "@id": "https://www.tib.eu/de/suchen/id/TIBKAT%3A168899274X",
            "@type": "bibo:Report",
            "P1053": "Online-Ressource (34 Seiten, 1805 KB)",
            "creator": "Orejas, Fernando",
            "description": "Diagramme",
            "identifier": [
                "(doi)10.25932/publishup-42751",
                "(firstid)KXP:168899274X",
                "(ppn)168899274X",
                "(isbn13)9783869564623"
            ],
            "publisher": "Universitätsverlag Potsdam",
            "subject": [
                "(classificationName=bk, id=10640623X)54.32 - Rechnerkommunikation",
                "(classificationName=linseach:mapping)inf"
            ],
            "title": "A logic-based incremental approach to graph repair",
            "abstract": [
                "Graph repair, restoring consistency of a graph, plays a prominent role in several areas of computer science and beyond: For example, in model-driven engineering, the abstract syntax of models is usually encoded using graphs. Flexible edit operations temporarily create inconsistent graphs not representing a valid model, thus requiring graph repair. Similarly, in graph databases—managing the storage and manipulation of graph data—updates may cause that a given database does not satisfy some integrity constraints, requiring also graph repair. We present a logic-based incremental approach to graph repair, generating a sound and complete (upon termination) overview of least-changing repairs. In our context, we formalize consistency by so-called graph conditions being equivalent to first-order logic on graphs. We present two kind of repair algorithms: State-based repair restores consistency independent of the graph update history, whereas deltabased (or incremental) repair takes this history explicitly into account. Technically, our algorithms rely on an existing model generation algorithm for graph conditions implemented in AutoGraph. Moreover, the delta-based approach uses the new concept of satisfaction (ST) trees for encoding if and how a graph satisfies a graph condition. We then demonstrate how to manipulate these STs incrementally with respect to a graph update.Die Reparatur von Graphen, die Wiederherstellung der Konsistenz eines Graphen, spielt in mehreren Bereichen der Informatik und darüber hinaus eine herausragende Rolle: Beispielsweise wird in der modellgetriebenen Konstruktion die abstrakte Syntax von Modellen in der Regel mithilfe von Graphen kodiert. Flexible Bearbeitungsvorgänge erstellen vorübergehend inkonsistente Diagramme, die kein gültiges Modell darstellen, und erfordern daher eine Reparatur des Diagramms. Auf ähnliche Weise können Aktualisierungen in Graphendatenbanken - die das Speichern und Bearbeiten von Graphendaten verwalten - dazu führen, dass eine bestimmte Datenbank einige Integritätsbeschränkungen nicht erfüllt und auch eine Graphreparatur erforderlich macht.",
                "ir präsentieren einen logikbasierten inkrementellen Ansatz für die Graphreparatur, der eine solide und vollständige (nach Beendigung) Übersicht über die am wenigsten verändernden Reparaturen erstellt. In unserem Kontext formalisieren wir die Konsistenz mittels sogenannten Graphbedingungen die der Logik erster Ordnung in Graphen entsprechen. Wir stellen zwei Arten von Reparaturalgorithmen vor: Die zustandsbasierte Reparatur stellt die Konsistenz unabhängig vom Verlauf der Graphänderung wieder her, während die deltabasierte (oder inkrementelle) Reparatur diesen Verlauf explizit berücksichtigt. Technisch stützen sich unsere Algorithmen auf einen vorhandenen Modellgenerierungsalgorithmus für in AutoGraph implementierte Graphbedingungen. Darüber hinaus verwendet der deltabasierte Ansatz das neue Konzept der Erfüllungsbäume (STs) zum Kodieren, ob und wie ein Graph eine Graphbedingung erfüllt. Wir zeigen dann, wie diese STs in Bezug auf eine Graphaktualisierung inkrementell manipuliert werden."
            ],
            "contributor": "Technische Informationsbibliothek (TIB)",
            "dcterms:creator": [
                {
                    "@id": "gnd:131769251"
                },
                {
                    "@id": "gnd:1069348694"
                },
                {
                    "@id": "gnd:1068096934"
                }
            ],
            "issued": "2019",
            "language": "http://id.loc.gov/vocabulary/iso639-1/de",
            "license": "open access",
            "medium": "rda:termList/RDACarrierType/1018",
            "dcterms:subject": [
                {
                    "@id": "gnd:4053474-1"
                },
                {
                    "@id": "gnd:7623494-0"
                },
                {
                    "@id": "gnd:4123065-6"
                },
                {
                    "@id": "gnd:4006650-2"
                }
            ],
            "volume": "Nr. 126",
            "isLike": "doi:10.25932/publishup-42751",
            "P30128": "Technische Berichte des Hasso-Plattner-Instituts für Digital Engineering an der Universität Potsdam",
            "P60163": "Potsdam"
        }
    ],
    "@id": "urn:x-arq:DefaultGraphNode",
    "@context": {
        "sameAs": "http://www.w3.org/2002/07/owl#sameAs",
        "identifier": "http://purl.org/dc/elements/1.1/identifier",
        "creator": "http://purl.org/dc/elements/1.1/creator",
        "publisher": "http://purl.org/dc/elements/1.1/publisher",
        "issued": "http://purl.org/dc/terms/issued",
        "P30128": "http://www.rdaregistry.info/Elements/m/#P30128",
        "medium": {
            "@id": "http://purl.org/dc/terms/medium",
            "@type": "@id"
        },
        "P60163": "http://www.rdaregistry.info/Elements/u/#P60163",
        "abstract": "http://purl.org/dc/terms/abstract",
        "title": "http://purl.org/dc/elements/1.1/title",
        "contributor": "http://purl.org/dc/terms/contributor",
        "subject": "http://purl.org/dc/elements/1.1/subject",
        "description": "http://purl.org/dc/elements/1.1/description",
        "volume": "http://purl.org/ontology/bibo/volume",
        "P1053": "http://iflastandards.info/ns/isbd/elements/P1053",
        "language": {
            "@id": "http://purl.org/dc/terms/language",
            "@type": "@id"
        },
        "license": "http://purl.org/dc/terms/license",
        "isLike": {
            "@id": "http://umbel.org/umbel#isLike",
            "@type": "@id"
        },
        "umbel": "http://umbel.org/umbel#",
        "rdau": "http://www.rdaregistry.info/Elements/u/#",
        "owl": "http://www.w3.org/2002/07/owl#",
        "dcterms": "http://purl.org/dc/terms/",
        "bibo": "http://purl.org/ontology/bibo/",
        "rdam": "http://www.rdaregistry.info/Elements/m/#",
        "gnd": "http://d-nb.info/gnd/",
        "isbd": "http://iflastandards.info/ns/isbd/elements/",
        "rda": "http://rdvocab.info/",
        "doi": "https://doi.org/"
    }
}